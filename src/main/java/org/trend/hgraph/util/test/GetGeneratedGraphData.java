/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.trend.hgraph.util.test;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.apache.commons.lang.time.StopWatch;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.hbase.HBaseConfiguration;
import org.apache.hadoop.hbase.client.HTable;
import org.apache.hadoop.hbase.client.Result;
import org.apache.hadoop.hbase.client.ResultScanner;
import org.apache.hadoop.hbase.client.Scan;
import org.apache.hadoop.hbase.filter.FirstKeyOnlyFilter;
import org.apache.hadoop.hbase.util.Bytes;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.trend.hgraph.AbstractElement;
import org.trend.hgraph.Graph;
import org.trend.hgraph.HBaseGraphConstants;
import org.trend.hgraph.HBaseGraphFactory;

import com.tinkerpop.blueprints.Direction;
import com.tinkerpop.blueprints.Edge;
import com.tinkerpop.blueprints.Vertex;

/**
 * Get <code>Graph</code> data generated by <code>GeneratedTestData</code>.
 * 
 * Also print-out elapsed time for performance verification.
 * @author scott_miao
 *
 */
public class GetGeneratedGraphData extends Configured implements Tool {
  
  private static final Logger LOG = LoggerFactory.getLogger(GetGeneratedGraphData.class);
  
  private static final int DEFAULT_LEVEL_TO_TRAVERSE = 3;
  
  private int levelToTraverse = DEFAULT_LEVEL_TO_TRAVERSE;
  private String vertexTableName = null;
  private String edgeTableName = null;
  private String[] startVertexIds = null;
  
  
  @Override
  public int run(String[] args) throws Exception {
    int countIndex = -1;
    // Process command line args
    for (int i = 0; i < args.length; i++) {
      String cmd = args[i];

      if (cmd.startsWith("-")) {
        if (countIndex >= 0) {
          // command line args must be in the form: [opts] [count1
          // [count2 ...]]
          System.err.println("Invalid command line options");
          printUsageAndExit();
        }

        if (cmd.equals("--help") || cmd.equals("-h")) {
          // user asked for help, print the help and quit.
          printUsageAndExit();
        } else if (cmd.equals("-l")) {
          i++;
          
          if (i == args.length) {
            System.err
            .println("-l needs a numeric value argument.");
            printUsageAndExit();
          }
          
          try{
            this.levelToTraverse = Integer.parseInt(args[i]);
          } catch(NumberFormatException e) {
            System.err.println("-l needs a numeric value argument.");
            printUsageAndExit();
          }
        } else if(cmd.equals("-i")) {
          i++;
          
          if (i == args.length) {
            System.err
            .println("-i needs a String value argument.");
            printUsageAndExit();
          }
          
          this.startVertexIds = args[i].split(",");
        }
        
      } else if (countIndex < 0) {
        // keep track of first count specified by the user
        countIndex = i;
      }
    }
    
    if(args.length != countIndex + 2) {
      System.err.println("Missing vertex-table-name or edge-table-name");
      printUsageAndExit();
    }
    
    LoopRowKeysStrategy loopRowKeysStrategy = null;
    // set {vertex,edge}-table-name
    Configuration conf = this.getConf();
    this.vertexTableName = args[countIndex];
    conf.set(HBaseGraphConstants.HBASE_GRAPH_TABLE_VERTEX_NAME_KEY, this.vertexTableName);
    
    this.edgeTableName = args[countIndex + 1];
    conf.set(HBaseGraphConstants.HBASE_GRAPH_TABLE_EDGE_NAME_KEY, this.edgeTableName);
    
    LOG.info("-l:" + this.levelToTraverse + ", -i:" + Arrays.toString(this.startVertexIds) + 
        ", vertex-table-name:" + this.vertexTableName + ", edge-table-name:" + this.edgeTableName);
    
    // if user not specify start-vertex-id, select all
    if(null == this.startVertexIds || this.startVertexIds.length == 0) {
      loopRowKeysStrategy = this.getAllDataRowKeys();
    } else {
      loopRowKeysStrategy = new GetSomeRowKeysStrategy(this.startVertexIds);
    }
    
//    doBFSGetGeneratedGraphData(conf, this.levelToTraverse, loopRowKeysStrategy);
    doDFSGetGeneratedGraphData(conf, this.levelToTraverse, 0, null, loopRowKeysStrategy);
    return 0;
  }
  
  private LoopRowKeysStrategy getAllDataRowKeys() throws IOException {
    LoopRowKeysStrategy strategy = null;
    HTable table = null;
    ResultScanner rs = null;
    try {
      table = new HTable(this.getConf(), this.vertexTableName);
    
      Scan scan = new Scan();
      scan.setFilter(new FirstKeyOnlyFilter());
      rs = table.getScanner(scan);
      strategy = new GetAllRowKeysStrategy(table, rs);
    } catch (IOException e) {
      LOG.error("getSampleDataRowKey failed", e);
      throw e;
    }
    return strategy;
  }
  
  private static interface LoopRowKeysStrategy {
    boolean hasNext();
    String next();
    void close() throws Exception;
  }
  
  private static class GetAllRowKeysStrategy implements LoopRowKeysStrategy {
    
    private HTable table;
    private ResultScanner rs;
    private Iterator<Result> rIt;
    
    GetAllRowKeysStrategy(HTable table, ResultScanner rs) {
      super();
      this.table = table;
      this.rs = rs;
      this.rIt = rs.iterator();
    }

    @Override
    public boolean hasNext() {
      return this.rIt.hasNext();
    }

    @Override
    public String next() {
      Result r = this.rIt.next();
      String rowKey = Bytes.toString(r.getRow());
      return rowKey;
    }

    @Override
    public void close() throws Exception {
      if(null != this.rs) this.rs.close();
      try {
        if(null != this.table) this.table.close();
      } catch (IOException e) {
        LOG.error("close table:" + this.table + " failed", e);
        throw e;
      }
    }
    
  }
  
  private static class GetSomeRowKeysStrategy implements LoopRowKeysStrategy {
    
    private String[] rowKeys;
    private int idx = -1;
    
    /**
     * @param rowKeys
     */
    GetSomeRowKeysStrategy(String[] rowKeys) {
      super();
      this.rowKeys = rowKeys;
    }

    @Override
    public boolean hasNext() {
      boolean hasNext = false;
      if(this.idx + 1 < this.rowKeys.length) {
        hasNext = true;
        this.idx++;
      }
      return hasNext;
    }

    @Override
    public String next() {
      return this.rowKeys[this.idx];
    }

    @Override
    public void close() {
      //do nothing
    }
    
  }
  
  // depth-first-search
  private long doDFSGetGeneratedGraphData(
      Configuration conf, int levelToTraverse, int curLevel, 
      AbstractElement parentElement, LoopRowKeysStrategy rowKeysStrategy) throws Exception {
    
    if(curLevel > levelToTraverse) {
      LOG.info("reach last level:" + curLevel);
      return 0;
    }
    String rowKey = null;
    Vertex vertex = null;
    int level = 1;
    long totalVertexCount = 0;
    long perRowKeyVertexCount = 0;
    if(null == parentElement) {
      level = 1;
      StopWatch timerAll = new StopWatch();
      StopWatch timerRowKey = null;
      Graph graph = null;
      timerAll.start();
      try {
        graph = HBaseGraphFactory.open(conf);
        while(rowKeysStrategy.hasNext()) {
          rowKey = rowKeysStrategy.next();
          LOG.info("***HEAD:Start to process rowKey:" + rowKey + "***");
          LOG.info("***HEAD:level:" + level + "***");
          timerRowKey = new StopWatch();
          timerRowKey.start();
          vertex = graph.getVertex(rowKey);
          LOG.info("processing vertex:" + vertex.getId());
          vertex.getPropertyKeys();
          perRowKeyVertexCount = doDFSGetGeneratedGraphData(
              conf, levelToTraverse, level + 1, (AbstractElement)vertex, rowKeysStrategy);
          timerRowKey.stop();
          perRowKeyVertexCount++;
          totalVertexCount += perRowKeyVertexCount;
          LOG.info("Time elapsed:" + timerRowKey.toString() + ", " + timerRowKey.getTime() +  " for processing rowKey:" + 
              rowKey + " for " + perRowKeyVertexCount + " of vertices");
          LOG.info("***TAIL:level:" + level + "***");
          LOG.info("***TAIL:Stop to process rowKey:" + rowKey + "***");
        }
        timerAll.stop();
        LOG.info("Time elapsed:" + timerAll.toString() + ", " + timerAll.getTime() +  " for getting " + 
            totalVertexCount + " of vertices");
      } catch(Exception e) {
        LOG.error("Processing vertex failed for rowKey:" + rowKey, e);
        throw e;
      } finally {
        try {
          rowKeysStrategy.close();
        } catch (Exception e) {
          LOG.error("Close rowKeysStrategy faiiled", e);
          throw e;
        }
        graph.shutdown();
      }
      
    } else {
      org.trend.hgraph.Vertex parentVertex = (org.trend.hgraph.Vertex) parentElement;
      LOG.info("***HEAD:level:" + curLevel + "***");
      for(Edge edge : parentVertex.getEdges()) {
        LOG.info("processing edge:" + edge.getId());
        edge.getPropertyKeys();
        vertex = edge.getVertex(Direction.OUT);
        LOG.info("processing vertex:" + vertex.getId());
        totalVertexCount++;
        vertex.getPropertyKeys();
        
        totalVertexCount += doDFSGetGeneratedGraphData(
            conf, levelToTraverse, curLevel + 1, 
            (AbstractElement)vertex, rowKeysStrategy);
      }
      LOG.info("***TAIL:level:" + curLevel + "***");
    }
    
    return totalVertexCount;
  }
  
  
  // breadth-first-search
  private static void doBFSGetGeneratedGraphData(
      Configuration conf, int levelToTraverse, LoopRowKeysStrategy rowKeysStrategy) 
          throws Exception {
    StopWatch timerAll = new StopWatch();
    StopWatch timerRowKey = null;
    Graph graph = null;
    Vertex vertex = null;
    List<Vertex> curVertices = null;
    List<Vertex> subVertices = null;
    Iterable<Edge> subEdges = null;
    int level = 0;
    long totalVertexCount = 0;
    long perVertexCount = 0;
    String rowKey = null;
    try {
      timerAll.start();
      graph = HBaseGraphFactory.open(conf);
      while(rowKeysStrategy.hasNext()) {
        rowKey = rowKeysStrategy.next();
        LOG.info("***HEAD:Start to process rowKey:" + rowKey + "***");
        timerRowKey = new StopWatch();
        timerRowKey.start();
        vertex = graph.getVertex(rowKey);
        curVertices = Arrays.asList(vertex);
        perVertexCount = 0; level = 0;
        while(level < levelToTraverse) {
          level++;
          LOG.info("***HEAD:level:" + level + "***");
          totalVertexCount += curVertices.size();
          perVertexCount += curVertices.size();
          subVertices = new ArrayList<Vertex>();
          for(Vertex tmpVertex : curVertices) {
            LOG.info("processing vertex:" + tmpVertex.getId());
            tmpVertex.getPropertyKeys();
            subEdges = ((org.trend.hgraph.Vertex) vertex).getEdges();
            for(Edge edge : subEdges) {
              LOG.info("processing edge:" + edge.getId());
              edge.getPropertyKeys();
              subVertices.add(edge.getVertex(Direction.OUT));
            }
          }
          curVertices = null;
          if(subVertices.size() == 0) {
            LOG.info("reach last level:" + level);
            break;
          }
          curVertices = subVertices;
        }
        timerRowKey.stop();
        LOG.info("Time elapsed:" + timerRowKey.toString() + ", " + timerRowKey.getTime() +  " for processing rowKey:" + 
            rowKey + " for " + perVertexCount + " of vertices");
        LOG.info("***TAIL:Stop to process rowKey:" + rowKey + "***");
      }
      timerAll.stop();
      LOG.info("Time elapsed:" + timerAll.toString() + ", " + timerAll.getTime() +  " for getting " + 
          totalVertexCount + " of vertices");
    } catch(Exception e) {
      LOG.error("Processing vertex failed for rowKey:" + rowKey, e);
      throw e;
    } finally {
      try {
        rowKeysStrategy.close();
      } catch (Exception e) {
        LOG.error("Close rowKeysStrategy faiiled", e);
        throw e;
      }
      graph.shutdown();
    }
  }
  
  private static void printUsageAndExit() {
    System.err.print(GetGeneratedGraphData.class.getSimpleName() + " Usage:");
    System.out.print("[-D [generic-option][...]]");
    System.err.println(" [-l level-to-traverse] [-i start-vertex-ids] <vertex-table-name> <edge-table-name>");
    System.err.println("-l level-to-traverse default value:" + DEFAULT_LEVEL_TO_TRAVERSE);
    System.err.println("-i start-vertex-ids user can specify what vertex-ids to start, delimitered by ','");
    System.err.println("    get all vertex-ids if not specified");
    System.exit(1);
  }
  
  
  public static void main(String args[]) throws Exception {
    Configuration conf = HBaseConfiguration.create();
    int returnCode = ToolRunner.run(conf, new GetGeneratedGraphData(), args);
    System.exit(returnCode);
  }
  
}
